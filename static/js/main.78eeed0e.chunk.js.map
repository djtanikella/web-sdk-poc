{"version":3,"sources":["utils.js","ErrorMessage.js","Webcam.js","Position.js","reportWebVitals.js","index.js"],"names":["videoElement","a","mediaConstraints","video","audio","navigator","mediaDevices","getUserMedia","stream","srcObject","console","error","calculateRoll","pt1","pt2","deltaX","deltaY","Math","atan2","PI","calculateYaw","deltaZ","calculatePitch","THRESHOLDS","ErrorMessage","scan","state","message","opacity","style","className","Position","props","metric","pointOne","pointTwo","name","value","toFixed","Webcam","webcamRef","useRef","webcamReady","useState","setError","roll","setRoll","yaw","setYaw","pitch","setPitch","leftEye","setLeftEye","rightEye","setRightEye","forehead","setForehead","chin","setChin","Date","now","lastUpdated","setLastUpdated","stopWebcam","log","clearInterval","current","setupMesh","start","faceLandmarksDetection","mediapipeFacemesh","shouldLoadIrisModel","model","estimateFaces","input","predictIrises","predictions","scaledMesh","leftEyePoint","rightEyePoint","chinPoint","foreheadPoint","faces","length","errorHandling","end","abs","useEffect","requestAccessAndStartVideo","setInterval","onloadeddata","e","videoStyles","border","transform","borderRadius","objectFit","rollProps","yawProps","pitchProps","id","width","height","autoPlay","muted","ref","onClick","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.78eeed0e.chunk.js","sourcesContent":["/**\n * requestAccessAndstartVideo takes a video element and sets the stream to the user's webcam\n * @param {HTMLElement} videoElement takes in a video element\n */\nexport async function requestAccessAndStartVideo(videoElement) {\n  const mediaConstraints = { video: true, audio: false };\n\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia(mediaConstraints);\n    videoElement.srcObject = stream;\n  } catch (e) {\n    console.error(e);\n  }\n}\n\n/**\n * calculateRoll takes two points and returns the roll in degrees\n * @param {number[]} pt1 coordinates in [x, y, z]\n * @param {number[]} pt2 cooridnates in [x, y, z]\n * @return {number} a number in degrees\n */\nexport function calculateRoll(pt1, pt2) {\n  const deltaX = pt2[0] - pt1[0];\n  const deltaY = pt2[1] - pt1[1];\n\n  const radians = Math.atan2(deltaX, deltaY);\n  const degrees = radians * (180 / Math.PI);\n\n  return degrees - 90;\n  // return roll;\n}\n\n/**\n * calculateYaw takes two points and returns the roll in degrees\n * @param {number[]} pt1 coordinates in [x, y, z]\n * @param {number[]} pt2 cooridnates in [x, y, z]\n * @return {number} a number in degrees\n */\nexport function calculateYaw(pt1, pt2) {\n  const deltaX = pt2[0] - pt1[0];\n  const deltaZ = pt2[2] - pt1[2];\n\n  const radians = Math.atan2(deltaX, deltaZ);\n  const degrees = radians * (180 / Math.PI);\n  return degrees - 90;\n}\n\n/**\n * calculatePitch takes two points and returns the roll in degrees\n * @param {number[]} pt1 coordinates in [x, y, z]\n * @param {number[]} pt2 cooridnates in [x, y, z]\n * @return {number} a number in degrees\n */\nexport function calculatePitch(pt1, pt2) {\n  const deltaY = pt2[1] - pt1[1];\n  const deltaZ = pt2[2] - pt1[2];\n\n  const radians = Math.atan2(deltaY, deltaZ);\n  const degrees = radians * (180 / Math.PI);\n  return degrees + 90;\n}\n\nexport const THRESHOLDS = {\n  YAW: 3,\n  ROLL: 3,\n  PITCH: 5,\n};\n\n// possible way to get position in one function if needed\n// function calculatePosition({\n//   chinPoint,\n//   foreheadPoint,\n//   leftEyePoint,\n//   rightEyePoint,\n// }) {\n//   //cacluate roll and yaw using eyes\n//   const deltaX = rightEyePoint[0] - leftEyePoint[0];\n//   let deltaY = rightEyePoint[1] - leftEyePoint[1];\n//   let deltaZ = rightEyePoint[2] - leftEyePoint[2];\n\n//   const rollRadians = Math.atan2(deltaX, deltaY);\n//   const roll = rollRadians * (180 / Math.PI) - 90;\n\n//   const yawRadians = Math.atan2(deltaX, deltaZ);\n//   const yaw = yawRadians * (180 / Math.PI) - 90;\n\n//   // calculate pitch using chin and forehead\n//   deltaY = chinPoint[1] - foreheadPoint[1];\n//   deltaZ = chinPoint[2] - foreheadPoint[1];\n\n//   const pitchRadians = Math.atan(deltaY, deltaZ);\n//   const pitch = pitchRadians * (180 / Math.PI) + 90;\n\n//   return {\n//     roll,\n//     yaw,\n//     pitch,\n//   };\n// }\n","import React from \"react\";\nimport \"./App.scss\";\n\nfunction ErrorMessage({ state, message }) {\n  const opacity = state ? 1 : 0;\n  return (\n    <div style={{ opacity }} className=\"errorBox\">\n      {message}\n    </div>\n  );\n}\n\nexport default ErrorMessage;\n","import React, { useRef, useEffect, useState } from \"react\";\nimport * as faceLandmarksDetection from \"@tensorflow-models/face-landmarks-detection\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport \"@tensorflow/tfjs-backend-cpu\";\n\nimport {\n  calculateRoll,\n  calculateYaw,\n  calculatePitch,\n  THRESHOLDS,\n  requestAccessAndStartVideo,\n} from \"./utils\";\nimport ErrorMessage from \"./ErrorMessage\";\nimport Position from \"./Position\";\nimport \"./App.scss\";\n\nlet scan;\n\nfunction Webcam() {\n  const webcamRef = useRef(null);\n  const webcamReady = useRef(false);\n  const [error, setError] = useState({\n    state: true,\n    message: \"Looking for a face...\",\n  });\n\n  const [roll, setRoll] = useState(0);\n  const [yaw, setYaw] = useState(0);\n  const [pitch, setPitch] = useState(0);\n\n  const [leftEye, setLeftEye] = useState([]);\n  const [rightEye, setRightEye] = useState([]);\n  const [forehead, setForehead] = useState([]);\n  const [chin, setChin] = useState([]);\n  const [lastUpdated, setLastUpdated] = useState(Date.now());\n\n  useEffect(() => {\n    requestAccessAndStartVideo(webcamRef.current);\n    scan = setInterval(() => {\n      setupMesh();\n    }, 300);\n\n    return () => stopWebcam();\n  }, []);\n\n  useEffect(() => {\n    if (webcamRef.current) {\n      webcamRef.current.onloadeddata = (e) => {\n        console.log(\"onloadedata fired \", e);\n        webcamReady.current = true;\n        setupMesh();\n      };\n    }\n  }, [webcamRef.current]);\n\n  function stopWebcam() {\n    console.log(\"stopwebcam called\");\n    clearInterval(scan);\n    webcamRef.current = null;\n  }\n\n  async function setupMesh() {\n    const start = Date.now();\n    if (!webcamRef.current || !webcamReady.current) return;\n\n    try {\n      const model = await faceLandmarksDetection.load(\n        faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,\n        { shouldLoadIrisModel: false }\n      );\n\n      const predictions = await model.estimateFaces({\n        input: webcamRef.current,\n        predictIrises: false,\n      });\n\n      const scaledMesh = predictions[0] && predictions[0].scaledMesh;\n      if (scaledMesh) {\n        const leftEyePoint = scaledMesh[133];\n        const rightEyePoint = scaledMesh[362];\n        const chinPoint = scaledMesh[199];\n        const foreheadPoint = scaledMesh[151];\n\n        const now = Date.now();\n\n        if (now > lastUpdated) {\n          setLeftEye(leftEyePoint);\n          setRightEye(rightEyePoint);\n          setForehead(foreheadPoint);\n          setChin(chinPoint);\n\n          const roll = calculateRoll(leftEyePoint, rightEyePoint);\n          const yaw = calculateYaw(leftEyePoint, rightEyePoint);\n          const pitch = calculatePitch(chinPoint, foreheadPoint);\n          const faces = predictions.length;\n\n          setRoll(roll);\n          setYaw(yaw);\n          setPitch(pitch);\n          setLastUpdated(now);\n\n          errorHandling({ roll, yaw, pitch, faces });\n        }\n      }\n      const end = Date.now();\n      console.log(\"ms: \", end - start);\n    } catch (err) {\n      console.error(\"error in the setup mesh fn\", err);\n    }\n  }\n\n  function errorHandling({ roll, yaw, pitch, faces }) {\n    if (faces !== 1) {\n      setError({\n        state: true,\n        message: `It seems like there are ${faces} faces`,\n      });\n    } else if (Math.abs(roll) > THRESHOLDS.ROLL) {\n      const correction = roll > 0 ? \"counter clockwise ↪️\" : \"clockwise ↩️\";\n      setError({\n        state: true,\n        message: `Turn your head ${correction}`,\n      });\n    } else if (Math.abs(yaw) > THRESHOLDS.YAW) {\n      const correction = yaw > 0 ? \"left ⬅️\" : \"right ➡️\";\n      setError({\n        state: true,\n        message: `Turn your head to the ${correction}`,\n      });\n    } else if (Math.abs(pitch) > THRESHOLDS.PITCH) {\n      const correction = pitch > 0 ? \"down ⬇️\" : \"up ⬆️\";\n      setError({\n        state: true,\n        message: `Turn your head ${correction}`,\n      });\n    } else {\n      setError({\n        state: false,\n        message: \"\",\n      });\n    }\n  }\n\n  const videoStyles = {\n    border: error.state ? \"10px solid #ff1744\" : \"15px solid teal\",\n    transform: \"scaleX(-1)\",\n    borderRadius: \"40%\",\n    objectFit: \"cover\",\n  };\n\n  const rollProps = {\n    metric: {\n      name: \"Roll\",\n      value: roll.toFixed(0),\n    },\n    pointOne: {\n      name: \"Left Eye\",\n      value: leftEye,\n    },\n    pointTwo: {\n      name: \"Right Eye\",\n      value: rightEye,\n    },\n  };\n\n  const yawProps = {\n    metric: {\n      name: \"Yaw\",\n      value: yaw.toFixed(0),\n    },\n    pointOne: {\n      name: \"Left Eye\",\n      value: leftEye,\n    },\n    pointTwo: {\n      name: \"Right Eye\",\n      value: rightEye,\n    },\n  };\n\n  const pitchProps = {\n    metric: {\n      name: \"Pitch\",\n      value: pitch.toFixed(0),\n    },\n    pointOne: {\n      name: \"Forehead\",\n      value: forehead,\n    },\n    pointTwo: {\n      name: \"Chin\",\n      value: chin,\n    },\n  };\n\n  return (\n    <div className=\"container\">\n      <video\n        id=\"webcam\"\n        width=\"550\"\n        height=\"500\"\n        autoPlay\n        style={videoStyles}\n        muted\n        ref={webcamRef}\n      />\n      <button onClick={() => stopWebcam()}>stop</button>\n      <button onClick={() => setupMesh()}>capture</button>\n      <ErrorMessage {...error} />\n      <div className=\"positioningBoxes\">\n        <Position {...rollProps} />\n        <Position {...yawProps} />\n        <Position {...pitchProps} />\n      </div>\n    </div>\n  );\n}\n\nexport default Webcam;\n","import React from \"react\";\nimport \"./App.scss\";\n\nexport default function Position(props) {\n  const { metric, pointOne, pointTwo } = props;\n\n  return (\n    <div className=\"positionCard\">\n      <div className=\"primaryValue\">\n        {metric.name}: {metric.value}&#176;\n      </div>\n      <div className=\"coordinates\">\n        <div>\n          <h2>{pointOne.name}</h2>\n          <pre>x: {pointOne.value[0] && pointOne.value[0].toFixed(1)}</pre>\n          <pre>y: {pointOne.value[1] && pointOne.value[1].toFixed(1)}</pre>\n          <pre>z: {pointOne.value[2] && pointOne.value[2].toFixed(1)}</pre>\n        </div>\n        <div>\n          <h2>{pointTwo.name}</h2>\n          <pre>x: {pointTwo.value[0] && pointTwo.value[0].toFixed(1)}</pre>\n          <pre>y: {pointTwo.value[1] && pointTwo.value[1].toFixed(1)}</pre>\n          <pre>z: {pointTwo.value[2] && pointTwo.value[2].toFixed(1)}</pre>\n        </div>\n      </div>\n    </div>\n  );\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n// import App from \"./App\";\nimport Webcam from \"./Webcam\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    {/* <App /> */}\n    <Webcam />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}